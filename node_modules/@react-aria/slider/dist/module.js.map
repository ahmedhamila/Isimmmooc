{"mappings":"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","sources":["packages/@react-aria/slider/src/index.ts","packages/@react-aria/slider/src/useSlider.ts","packages/@react-aria/slider/src/utils.ts","packages/@react-aria/slider/src/useSliderThumb.ts"],"sourcesContent":["/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\nexport {useSlider} from './useSlider';\nexport {useSliderThumb} from './useSliderThumb';\nexport type {AriaSliderProps} from '@react-types/slider';\nexport type {SliderAria} from './useSlider';\nexport type {AriaSliderThumbOptions, SliderThumbAria} from './useSliderThumb';\n","/*\n * Copyright 2020 Adobe. All rights reserved.\n * This file is licensed to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License. You may obtain a copy\n * of the License at http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under\n * the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS\n * OF ANY KIND, either express or implied. See the License for the specific language\n * governing permissions and limitations under the License.\n */\n\nimport {AriaSliderProps} from '@react-types/slider';\nimport {clamp, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {LabelHTMLAttributes, OutputHTMLAttributes, RefObject, useRef} from 'react';\nimport {setInteractionModality, useMove} from '@react-aria/interactions';\nimport {SliderState} from '@react-stately/slider';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderAria {\n  /** Props for the label element. */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Props for the root element of the slider component; groups slider inputs. */\n  groupProps: DOMAttributes,\n\n  /** Props for the track element. */\n  trackProps: DOMAttributes,\n\n  /** Props for the output element, displaying the value of the slider thumbs. */\n  outputProps: OutputHTMLAttributes<HTMLOutputElement>\n}\n\n/**\n * Provides the behavior and accessibility implementation for a slider component representing one or more values.\n *\n * @param props Props for the slider.\n * @param state State for the slider, as returned by `useSliderState`.\n * @param trackRef Ref for the \"track\" element.  The width of this element provides the \"length\"\n * of the track -- the span of one dimensional space that the slider thumb can be.  It also\n * accepts click and drag motions, so that the closest thumb will follow clicks and drags on\n * the track.\n */\nexport function useSlider<T extends number | number[]>(\n  props: AriaSliderProps<T>,\n  state: SliderState,\n  trackRef: RefObject<Element>\n): SliderAria {\n  let {labelProps, fieldProps} = useLabel(props);\n\n  let isVertical = props.orientation === 'vertical';\n\n  // Attach id of the label to the state so it can be accessed by useSliderThumb.\n  sliderIds.set(state, labelProps.id ?? fieldProps.id);\n\n  let {direction} = useLocale();\n\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  // When the user clicks or drags the track, we want the motion to set and drag the\n  // closest thumb.  Hence we also need to install useMove() on the track element.\n  // Here, we keep track of which index is the \"closest\" to the drag start point.\n  // It is set onMouseDown/onTouchDown; see trackProps below.\n  const realTimeTrackDraggingIndex = useRef<number | null>(null);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  const reverseX = direction === 'rtl';\n  const currentPosition = useRef<number>(null);\n  const {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n    },\n    onMove({deltaX, deltaY}) {\n      let {height, width} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = stateRef.current.getThumbPercent(realTimeTrackDraggingIndex.current) * size;\n      }\n\n      let delta = isVertical ? deltaY : deltaX;\n      if (isVertical || reverseX) {\n        delta = -delta;\n      }\n\n      currentPosition.current += delta;\n\n      if (realTimeTrackDraggingIndex.current != null && trackRef.current) {\n        const percent = clamp(currentPosition.current / size, 0, 1);\n        stateRef.current.setThumbPercent(realTimeTrackDraggingIndex.current, percent);\n      }\n    },\n    onMoveEnd() {\n      if (realTimeTrackDraggingIndex.current != null) {\n        stateRef.current.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  });\n\n  let currentPointer = useRef<number | null | undefined>(undefined);\n  let onDownTrack = (e: React.UIEvent, id: number, clientX: number, clientY: number) => {\n    // We only trigger track-dragging if the user clicks on the track itself and nothing is currently being dragged.\n    if (trackRef.current && !props.isDisabled && state.values.every((_, i) => !state.isThumbDragging(i))) {\n      let {height, width, top, left} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n      // Find the closest thumb\n      const trackPosition = isVertical ? top : left;\n      const clickPosition = isVertical ? clientY : clientX;\n      const offset = clickPosition - trackPosition;\n      let percent = offset / size;\n      if (direction === 'rtl' || isVertical) {\n        percent = 1 - percent;\n      }\n      let value = state.getPercentValue(percent);\n\n      // to find the closet thumb we split the array based on the first thumb position to the \"right/end\" of the click.\n      let closestThumb;\n      let split = state.values.findIndex(v => value - v < 0);\n      if (split === 0) { // If the index is zero then the closetThumb is the first one\n        closestThumb = split;\n      } else if (split === -1) { // If no index is found they've clicked past all the thumbs\n        closestThumb = state.values.length - 1;\n      } else {\n        let lastLeft = state.values[split - 1];\n        let firstRight = state.values[split];\n        // Pick the last left/start thumb, unless they are stacked on top of each other, then pick the right/end one\n        if (Math.abs(lastLeft - value) < Math.abs(firstRight - value)) {\n          closestThumb = split - 1;\n        } else {\n          closestThumb = split;\n        }\n      }\n\n      // Confirm that the found closest thumb is editable, not disabled, and move it\n      if (closestThumb >= 0 && state.isThumbEditable(closestThumb)) {\n        // Don't unfocus anything\n        e.preventDefault();\n\n        realTimeTrackDraggingIndex.current = closestThumb;\n        state.setFocusedThumb(closestThumb);\n        currentPointer.current = id;\n\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, true);\n        state.setThumbValue(closestThumb, value);\n\n        addGlobalListener(window, 'mouseup', onUpTrack, false);\n        addGlobalListener(window, 'touchend', onUpTrack, false);\n        addGlobalListener(window, 'pointerup', onUpTrack, false);\n      } else {\n        realTimeTrackDraggingIndex.current = null;\n      }\n    }\n  };\n\n  let onUpTrack = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      if (realTimeTrackDraggingIndex.current != null) {\n        state.setThumbDragging(realTimeTrackDraggingIndex.current, false);\n        realTimeTrackDraggingIndex.current = null;\n      }\n\n      removeGlobalListener(window, 'mouseup', onUpTrack, false);\n      removeGlobalListener(window, 'touchend', onUpTrack, false);\n      removeGlobalListener(window, 'pointerup', onUpTrack, false);\n    }\n  };\n\n  if ('htmlFor' in labelProps && labelProps.htmlFor) {\n    // Ideally the `for` attribute should point to the first thumb, but VoiceOver on iOS\n    // causes this to override the `aria-labelledby` on the thumb. This causes the first\n    // thumb to only be announced as the slider label rather than its individual name as well.\n    // See https://bugs.webkit.org/show_bug.cgi?id=172464.\n    delete labelProps.htmlFor;\n    labelProps.onClick = () => {\n      // Safari does not focus <input type=\"range\"> elements when clicking on an associated <label>,\n      // so do it manually. In addition, make sure we show the focus ring.\n      document.getElementById(getSliderThumbId(state, 0))?.focus();\n      setInteractionModality('keyboard');\n    };\n  }\n\n  return {\n    labelProps,\n    // The root element of the Slider will have role=\"group\" to group together\n    // all the thumb inputs in the Slider.  The label of the Slider will\n    // be used to label the group.\n    groupProps: {\n      role: 'group',\n      ...fieldProps\n    },\n    trackProps: mergeProps({\n      onMouseDown(e: React.MouseEvent) {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDownTrack(e, undefined, e.clientX, e.clientY);\n      },\n      onPointerDown(e: React.PointerEvent) {\n        if (e.pointerType === 'mouse' && (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey)) {\n          return;\n        }\n        onDownTrack(e, e.pointerId, e.clientX, e.clientY);\n      },\n      onTouchStart(e: React.TouchEvent) { onDownTrack(e, e.changedTouches[0].identifier, e.changedTouches[0].clientX, e.changedTouches[0].clientY); },\n      style: {\n        position: 'relative',\n        touchAction: 'none'\n      }\n    }, moveProps),\n    outputProps: {\n      htmlFor: state.values.map((_, index) => getSliderThumbId(state, index)).join(' '),\n      'aria-live': 'off'\n    }\n  };\n}\n","import {SliderState} from '@react-stately/slider';\n\nexport const sliderIds = new WeakMap<SliderState, string>();\n\nexport function getSliderThumbId(state: SliderState, index: number) {\n  let id = sliderIds.get(state);\n  if (!id) {\n    throw new Error('Unknown slider state');\n  }\n\n  return `${id}-${index}`;\n}\n","import {AriaSliderThumbProps} from '@react-types/slider';\nimport {clamp, focusWithoutScrolling, mergeProps, useGlobalListeners} from '@react-aria/utils';\nimport {DOMAttributes} from '@react-types/shared';\nimport {getSliderThumbId, sliderIds} from './utils';\nimport React, {ChangeEvent, InputHTMLAttributes, LabelHTMLAttributes, RefObject, useCallback, useEffect, useRef} from 'react';\nimport {SliderState} from '@react-stately/slider';\nimport {useFocusable} from '@react-aria/focus';\nimport {useKeyboard, useMove} from '@react-aria/interactions';\nimport {useLabel} from '@react-aria/label';\nimport {useLocale} from '@react-aria/i18n';\n\nexport interface SliderThumbAria {\n  /** Props for the root thumb element; handles the dragging motion. */\n  thumbProps: DOMAttributes,\n\n  /** Props for the visually hidden range input element. */\n  inputProps: InputHTMLAttributes<HTMLInputElement>,\n\n  /** Props for the label element for this thumb (optional). */\n  labelProps: LabelHTMLAttributes<HTMLLabelElement>,\n\n  /** Whether this thumb is currently being dragged. */\n  isDragging: boolean,\n  /** Whether the thumb is currently focused. */\n  isFocused: boolean,\n  /** Whether the thumb is disabled. */\n  isDisabled: boolean\n}\n\nexport interface AriaSliderThumbOptions extends AriaSliderThumbProps {\n  /** A ref to the track element. */\n  trackRef: RefObject<Element>,\n  /** A ref to the thumb input element. */\n  inputRef: RefObject<HTMLInputElement>\n}\n\n/**\n * Provides behavior and accessibility for a thumb of a slider component.\n *\n * @param opts Options for this Slider thumb.\n * @param state Slider state, created via `useSliderState`.\n */\nexport function useSliderThumb(\n  opts: AriaSliderThumbOptions,\n  state: SliderState\n): SliderThumbAria {\n  let {\n    index,\n    isRequired,\n    validationState,\n    trackRef,\n    inputRef,\n    orientation = state.orientation\n  } = opts;\n\n  let isDisabled = opts.isDisabled || state.isDisabled;\n  let isVertical = orientation === 'vertical';\n\n  let {direction} = useLocale();\n  let {addGlobalListener, removeGlobalListener} = useGlobalListeners();\n\n  let labelId = sliderIds.get(state);\n  const {labelProps, fieldProps} = useLabel({\n    ...opts,\n    id: getSliderThumbId(state, index),\n    'aria-labelledby': `${labelId} ${opts['aria-labelledby'] ?? ''}`.trim()\n  });\n\n  const value = state.values[index];\n\n  const focusInput = useCallback(() => {\n    if (inputRef.current) {\n      focusWithoutScrolling(inputRef.current);\n    }\n  }, [inputRef]);\n\n  const isFocused = state.focusedThumb === index;\n\n  useEffect(() => {\n    if (isFocused) {\n      focusInput();\n    }\n  }, [isFocused, focusInput]);\n\n  const stateRef = useRef<SliderState>(null);\n  stateRef.current = state;\n  let reverseX = direction === 'rtl';\n  let currentPosition = useRef<number>(null);\n\n  let {keyboardProps} = useKeyboard({\n    onKeyDown(e) {\n      let {\n        getThumbMaxValue,\n        getThumbMinValue,\n        decrementThumb,\n        incrementThumb,\n        setThumbValue,\n        setThumbDragging,\n        pageSize\n      } = stateRef.current;\n      // these are the cases that useMove or useSlider don't handle\n      if (!/^(PageUp|PageDown|Home|End)$/.test(e.key)) {\n        e.continuePropagation();\n        return;\n      }\n      // same handling as useMove, stopPropagation to prevent useSlider from handling the event as well.\n      e.preventDefault();\n      // remember to set this so that onChangeEnd is fired\n      setThumbDragging(index, true);\n      switch (e.key) {\n        case 'PageUp':\n          incrementThumb(index, pageSize);\n          break;\n        case 'PageDown':\n          decrementThumb(index, pageSize);\n          break;\n        case 'Home':\n          setThumbValue(index, getThumbMinValue(index));\n          break;\n        case 'End':\n          setThumbValue(index, getThumbMaxValue(index));\n          break;\n      }\n      setThumbDragging(index, false);\n    }\n  });\n\n  let {moveProps} = useMove({\n    onMoveStart() {\n      currentPosition.current = null;\n      stateRef.current.setThumbDragging(index, true);\n    },\n    onMove({deltaX, deltaY, pointerType, shiftKey}) {\n      const {\n        getThumbPercent,\n        setThumbPercent,\n        decrementThumb,\n        incrementThumb,\n        step,\n        pageSize\n      } = stateRef.current;\n      let {width, height} = trackRef.current.getBoundingClientRect();\n      let size = isVertical ? height : width;\n\n      if (currentPosition.current == null) {\n        currentPosition.current = getThumbPercent(index) * size;\n      }\n      if (pointerType === 'keyboard') {\n        if ((deltaX > 0 && reverseX) || (deltaX < 0 && !reverseX) || deltaY > 0) {\n          decrementThumb(index, shiftKey ? pageSize : step);\n        } else {\n          incrementThumb(index, shiftKey ? pageSize : step);\n        }\n      } else {\n        let delta = isVertical ? deltaY : deltaX;\n        if (isVertical || reverseX) {\n          delta = -delta;\n        }\n\n        currentPosition.current += delta;\n        setThumbPercent(index, clamp(currentPosition.current / size, 0, 1));\n      }\n    },\n    onMoveEnd() {\n      stateRef.current.setThumbDragging(index, false);\n    }\n  });\n\n  // Immediately register editability with the state\n  state.setThumbEditable(index, !isDisabled);\n\n  const {focusableProps} = useFocusable(\n    mergeProps(opts, {\n      onFocus: () => state.setFocusedThumb(index),\n      onBlur: () => state.setFocusedThumb(undefined)\n    }),\n    inputRef\n  );\n\n  let currentPointer = useRef<number | undefined>(undefined);\n  let onDown = (id?: number) => {\n    focusInput();\n    currentPointer.current = id;\n    state.setThumbDragging(index, true);\n\n    addGlobalListener(window, 'mouseup', onUp, false);\n    addGlobalListener(window, 'touchend', onUp, false);\n    addGlobalListener(window, 'pointerup', onUp, false);\n\n  };\n\n  let onUp = (e) => {\n    let id = e.pointerId ?? e.changedTouches?.[0].identifier;\n    if (id === currentPointer.current) {\n      focusInput();\n      state.setThumbDragging(index, false);\n      removeGlobalListener(window, 'mouseup', onUp, false);\n      removeGlobalListener(window, 'touchend', onUp, false);\n      removeGlobalListener(window, 'pointerup', onUp, false);\n    }\n  };\n\n  let thumbPosition = state.getThumbPercent(index);\n  if (isVertical || direction === 'rtl') {\n    thumbPosition = 1 - thumbPosition;\n  }\n\n  let interactions = !isDisabled ? mergeProps(\n    keyboardProps,\n    moveProps,\n    {\n      onMouseDown: (e: React.MouseEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown();\n      },\n      onPointerDown: (e: React.PointerEvent) => {\n        if (e.button !== 0 || e.altKey || e.ctrlKey || e.metaKey) {\n          return;\n        }\n        onDown(e.pointerId);\n      },\n      onTouchStart: (e: React.TouchEvent) => {onDown(e.changedTouches[0].identifier);}\n    }\n  ) : {};\n\n  // We install mouse handlers for the drag motion on the thumb div, but\n  // not the key handler for moving the thumb with the slider.  Instead,\n  // we focus the range input, and let the browser handle the keyboard\n  // interactions; we then listen to input's onChange to update state.\n  return {\n    inputProps: mergeProps(focusableProps, fieldProps, {\n      type: 'range',\n      tabIndex: !isDisabled ? 0 : undefined,\n      min: state.getThumbMinValue(index),\n      max: state.getThumbMaxValue(index),\n      step: state.step,\n      value: value,\n      disabled: isDisabled,\n      'aria-orientation': orientation,\n      'aria-valuetext': state.getThumbValueLabel(index),\n      'aria-required': isRequired || undefined,\n      'aria-invalid': validationState === 'invalid' || undefined,\n      'aria-errormessage': opts['aria-errormessage'],\n      onChange: (e: ChangeEvent<HTMLInputElement>) => {\n        stateRef.current.setThumbValue(index, parseFloat(e.target.value));\n      }\n    }),\n    thumbProps: {\n      ...interactions,\n      style: {\n        position: 'absolute',\n        [isVertical ? 'top' : 'left']: `${thumbPosition * 100}%`,\n        transform: 'translate(-50%, -50%)',\n        touchAction: 'none'\n      }\n    },\n    labelProps,\n    isDragging: state.isThumbDragging(index),\n    isDisabled,\n    isFocused\n  };\n}\n"],"names":[],"version":3,"file":"module.js.map"}