import {Section as $6555104ff085bef4$re_export$Section, useCollection as $1BfjW$useCollection} from "@react-stately/collections";
import $1BfjW$react, {useState as $1BfjW$useState, useMemo as $1BfjW$useMemo, useCallback as $1BfjW$useCallback} from "react";
import $1BfjW$swchelperssrc_define_propertymjs from "@swc/helpers/src/_define_property.mjs";
import {useGridState as $1BfjW$useGridState, GridCollection as $1BfjW$GridCollection} from "@react-stately/grid";

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ /*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
/*
 * Copyright 2022 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $6818b1c4fc67028d$export$1994a077b98ee0d5(width) {
    return width != null && (!isNaN(width) || String(width).match(/^(\d+)(?=%$)/) !== null);
}
function $6818b1c4fc67028d$export$9078bad4c3934604(width) {
    if (!width) return 1;
    let match = width.match(/^(.+)(?=fr$)/);
    // if width is the incorrect format, just default it to a 1fr
    if (!match) {
        console.warn(`width: ${width} is not a supported format, width should be a number (ex. 150), percentage (ex. '50%') or fr unit (ex. '2fr')`, "defaulting to '1fr'");
        return 1;
    }
    return parseFloat(match[0]);
}
function $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, tableWidth) {
    if (typeof width === "string") {
        let match = width.match(/^(\d+)(?=%$)/);
        if (!match) throw new Error("Only percentages or numbers are supported for static column widths");
        return tableWidth * (parseFloat(match[0]) / 100);
    }
    return width;
}
function $6818b1c4fc67028d$export$59185c62a7544aa0(maxWidth, tableWidth) {
    return maxWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(maxWidth, tableWidth) : Number.MAX_SAFE_INTEGER;
}
function $6818b1c4fc67028d$export$f556054ce4358701(minWidth, tableWidth) {
    return minWidth != null ? $6818b1c4fc67028d$export$7bbad27896f7ae9f(minWidth, tableWidth) : 0;
}
// tell us the delta between min width and target width vs max width and target width
function $6818b1c4fc67028d$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth) {
    let fractions = dynamicColumns.reduce((sum, column)=>column ? sum + $6818b1c4fc67028d$export$9078bad4c3934604(column.column.width || column.column.defaultWidth) : sum, 0);
    let columns = dynamicColumns.map((column)=>{
        if (!column) return null;
        const targetWidth = $6818b1c4fc67028d$export$9078bad4c3934604(column.column.width || column.column.defaultWidth) * availableSpace / fractions;
        const delta = Math.max($6818b1c4fc67028d$export$f556054ce4358701(column.column.minWidth, tableWidth) - targetWidth, targetWidth - $6818b1c4fc67028d$export$59185c62a7544aa0(column.column.maxWidth, tableWidth));
        return {
            ...column,
            delta: delta
        };
    });
    return columns;
}
// mutates columns to set their width
function $6818b1c4fc67028d$var$findDynamicColumnWidths(dynamicColumns, availableSpace, tableWidth) {
    let fractions = dynamicColumns.reduce((sum, col)=>col ? sum + col.width : sum, 0);
    dynamicColumns.forEach((column)=>{
        if (!column) return null;
        const targetWidth = column.width * availableSpace / fractions;
        let width = Math.max($6818b1c4fc67028d$export$f556054ce4358701(column.column.minWidth, tableWidth), Math.min(Math.round(targetWidth), $6818b1c4fc67028d$export$59185c62a7544aa0(column.column.maxWidth, tableWidth)));
        availableSpace -= width;
        fractions -= column.width;
        column.width = width;
    });
}
function $6818b1c4fc67028d$export$a870e6692ac5ccb2(dynamicColumns, availableSpace, tableWidth) {
    let columns = $6818b1c4fc67028d$var$mapDynamicColumns(dynamicColumns, availableSpace, tableWidth);
    // sort is nlogn and copying is n, so copying and sorting is faster than sorting twice
    // sort by delta's to prioritize assigning width
    let sorted = [
        ...columns
    ].sort((a, b)=>{
        if (a && b) return b.delta - a.delta;
        return a ? -1 : 1;
    });
    // this function mutates the column entries, so no need to have it return anything
    // plus we don't need to undo the sort since we already have the correct order
    $6818b1c4fc67028d$var$findDynamicColumnWidths(sorted, availableSpace, tableWidth);
    return columns;
}
function $6818b1c4fc67028d$export$55d50dc687385491(availableWidth, columns, changedColumns, getDefaultWidth, getDefaultMinWidth) {
    let remainingSpace = availableWidth;
    let { staticColumns: staticColumns , dynamicColumns: dynamicColumns  } = columns.reduce((acc, column, index)=>{
        var _column_width, _ref, _ref1;
        let width = changedColumns.get(column.key) != null ? changedColumns.get(column.key) : (_ref1 = (_ref = (_column_width = column.width) !== null && _column_width !== void 0 ? _column_width : column.defaultWidth) !== null && _ref !== void 0 ? _ref : getDefaultWidth === null || getDefaultWidth === void 0 ? void 0 : getDefaultWidth(index)) !== null && _ref1 !== void 0 ? _ref1 : "1fr";
        var _column_minWidth;
        let minWidth = (_column_minWidth = column.minWidth) !== null && _column_minWidth !== void 0 ? _column_minWidth : getDefaultMinWidth === null || getDefaultMinWidth === void 0 ? void 0 : getDefaultMinWidth(index);
        column.minWidth = minWidth;
        if ($6818b1c4fc67028d$export$1994a077b98ee0d5(width)) {
            let w = $6818b1c4fc67028d$export$7bbad27896f7ae9f(width, availableWidth);
            w = Math.max($6818b1c4fc67028d$export$f556054ce4358701(column.minWidth, availableWidth), Math.min(Math.floor(w), $6818b1c4fc67028d$export$59185c62a7544aa0(column.maxWidth, availableWidth)));
            acc.staticColumns.push({
                index: index,
                column: column,
                width: w
            });
            acc.dynamicColumns.push(null);
            remainingSpace -= w;
        } else {
            let w1 = $6818b1c4fc67028d$export$9078bad4c3934604(width);
            acc.staticColumns.push(null);
            acc.dynamicColumns.push({
                index: index,
                column: column,
                width: w1
            });
        }
        return acc;
    }, {
        staticColumns: [],
        dynamicColumns: []
    });
    let newColWidths = $6818b1c4fc67028d$export$a870e6692ac5ccb2(dynamicColumns, remainingSpace, availableWidth);
    return staticColumns.map((col, i)=>{
        if (col) return col.width;
        return newColWidths[i].width;
    });
}


class $a9e7ae544a4e41dd$export$7ff77a162970b30e {
    /** Takes an array of columns and splits it into 2 maps of columns with controlled and columns with uncontrolled widths. */ splitColumnsIntoControlledAndUncontrolled(columns) {
        return columns.reduce((acc, col)=>{
            if (col.props.width != null) acc[0].set(col.key, col);
            else acc[1].set(col.key, col);
            return acc;
        }, [
            new Map(),
            new Map()
        ]);
    }
    /** Takes uncontrolled and controlled widths and joins them into a single Map. */ recombineColumns(columns, uncontrolledWidths, uncontrolledColumns, controlledColumns) {
        return new Map(columns.map((col)=>{
            if (uncontrolledColumns.has(col.key)) return [
                col.key,
                uncontrolledWidths.get(col.key)
            ];
            else return [
                col.key,
                controlledColumns.get(col.key).props.width
            ];
        }));
    }
    /** Used to make an initial Map of the uncontrolled widths based on default widths. */ getInitialUncontrolledWidths(uncontrolledColumns) {
        var _col_props_defaultWidth, _ref;
        return new Map(Array.from(uncontrolledColumns).map(([key, col])=>{
            var _this, _this_getDefaultWidth;
            return [
                key,
                (_ref = (_col_props_defaultWidth = col.props.defaultWidth) !== null && _col_props_defaultWidth !== void 0 ? _col_props_defaultWidth : (_this_getDefaultWidth = (_this = this).getDefaultWidth) === null || _this_getDefaultWidth === void 0 ? void 0 : _this_getDefaultWidth.call(_this, col)) !== null && _ref !== void 0 ? _ref : "1fr"
            ];
        }));
    }
    getColumnWidth(key) {
        var _this_columnWidths_get;
        return (_this_columnWidths_get = this.columnWidths.get(key)) !== null && _this_columnWidths_get !== void 0 ? _this_columnWidths_get : 0;
    }
    getColumnMinWidth(key) {
        return this.columnMinWidths.get(key);
    }
    getColumnMaxWidth(key) {
        return this.columnMaxWidths.get(key);
    }
    resizeColumnWidth(tableWidth, collection, controlledWidths, uncontrolledWidths, col = null, width) {
        let prevColumnWidths = this.columnWidths;
        // resizing a column
        let resizeIndex = Infinity;
        let controlledArray = Array.from(controlledWidths);
        let uncontrolledArray = Array.from(uncontrolledWidths);
        let combinedArray = controlledArray.concat(uncontrolledArray);
        let resizingChanged = new Map(combinedArray);
        let frKeys = new Map();
        let percentKeys = new Map();
        let frKeysToTheRight = new Map();
        let minWidths = new Map();
        // freeze columns to the left to their previous pixel value
        // at the same time count how many total FR's are in play and which of those FRs are
        // to the right or left of the resizing column
        collection.columns.forEach((column, i)=>{
            var _column_column_props_width, _column_column_props_width_endsWith;
            let frKey;
            minWidths.set(column.key, this.getDefaultMinWidth(collection.columns[i]));
            if (col !== column.key && !column.column.props.width && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(uncontrolledWidths.get(column.key))) {
                // uncontrolled don't have props.width for us, so instead get from our state
                frKey = column.key;
                frKeys.set(column.key, (0, $6818b1c4fc67028d$export$9078bad4c3934604)(uncontrolledWidths.get(column.key)));
            } else if (col !== column.key && !(0, $6818b1c4fc67028d$export$1994a077b98ee0d5)(column.column.props.width) && !uncontrolledWidths.get(column.key)) {
                // controlledWidths will be the same in the collection
                frKey = column.key;
                frKeys.set(column.key, (0, $6818b1c4fc67028d$export$9078bad4c3934604)(column.column.props.width));
            } else if (col !== column.key && ((_column_column_props_width = column.column.props.width) === null || _column_column_props_width === void 0 ? void 0 : (_column_column_props_width_endsWith = _column_column_props_width.endsWith) === null || _column_column_props_width_endsWith === void 0 ? void 0 : _column_column_props_width_endsWith.call(_column_column_props_width, "%"))) percentKeys.set(column.key, column.column.props.width);
            // don't freeze columns to the right of the resizing one
            if (resizeIndex < i) {
                if (frKey) frKeysToTheRight.set(frKey, frKeys.get(frKey));
                return;
            }
            // we already know the new size of the resizing column
            if (column.key === col) {
                resizeIndex = i;
                return;
            }
            // freeze column to previous value
            resizingChanged.set(column.key, prevColumnWidths.get(column.key));
        });
        resizingChanged.set(col, Math.floor(width));
        // predict pixels sizes for all columns based on resize
        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({
                ...col.column.props,
                key: col.key
            })), resizingChanged, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));
        // set all new column widths for onResize event
        // columns going in will be the same order as the columns coming out
        let newWidths = new Map();
        // set all column widths based on calculateColumnSize
        columnWidths.forEach((width, index)=>{
            let key = collection.columns[index].key;
            newWidths.set(key, width);
        });
        // add FR's back as they were to columns to the right
        Array.from(frKeys).forEach(([key])=>{
            if (frKeysToTheRight.has(key)) newWidths.set(key, `${frKeysToTheRight.get(key)}fr`);
        });
        // put back in percents
        Array.from(percentKeys).forEach(([key, width])=>{
            // resizing locks a column to a px width
            if (key === col) return;
            newWidths.set(key, width);
        });
        return newWidths;
    }
    buildColumnWidths(tableWidth, collection, widths) {
        this.columnWidths = new Map();
        this.columnMinWidths = new Map();
        this.columnMaxWidths = new Map();
        // initial layout or table/window resizing
        let columnWidths = (0, $6818b1c4fc67028d$export$55d50dc687385491)(tableWidth, collection.columns.map((col)=>({
                ...col.column.props,
                key: col.key
            })), widths, (i)=>this.getDefaultWidth(collection.columns[i]), (i)=>this.getDefaultMinWidth(collection.columns[i]));
        // columns going in will be the same order as the columns coming out
        columnWidths.forEach((width, index)=>{
            let key = collection.columns[index].key;
            let column = collection.columns[index];
            this.columnWidths.set(key, width);
            var _column_column_props_minWidth;
            this.columnMinWidths.set(key, (0, $6818b1c4fc67028d$export$f556054ce4358701)((_column_column_props_minWidth = column.column.props.minWidth) !== null && _column_column_props_minWidth !== void 0 ? _column_column_props_minWidth : this.getDefaultMinWidth(column), tableWidth));
            this.columnMaxWidths.set(key, (0, $6818b1c4fc67028d$export$59185c62a7544aa0)(column.column.props.maxWidth, tableWidth));
        });
        return this.columnWidths;
    }
    constructor(options){
        (0, $1BfjW$swchelperssrc_define_propertymjs)(this, "columnWidths", new Map());
        (0, $1BfjW$swchelperssrc_define_propertymjs)(this, "columnMinWidths", new Map());
        (0, $1BfjW$swchelperssrc_define_propertymjs)(this, "columnMaxWidths", new Map());
        this.getDefaultWidth = options.getDefaultWidth;
        this.getDefaultMinWidth = options.getDefaultMinWidth;
    }
}


function $292bc4e09cd0eb62$export$cb895dcf85db1319(props, state) {
    let { getDefaultWidth: getDefaultWidth , getDefaultMinWidth: getDefaultMinWidth , onColumnResizeStart: propsOnColumnResizeStart , onColumnResizeEnd: propsOnColumnResizeEnd , tableWidth: tableWidth = 0  } = props;
    let [resizingColumn, setResizingColumn] = (0, $1BfjW$useState)(null);
    let columnLayout = (0, $1BfjW$useMemo)(()=>new (0, $a9e7ae544a4e41dd$export$7ff77a162970b30e)({
            getDefaultWidth: getDefaultWidth,
            getDefaultMinWidth: getDefaultMinWidth
        }), [
        getDefaultWidth,
        getDefaultMinWidth
    ]);
    let [controlledColumns, uncontrolledColumns] = (0, $1BfjW$useMemo)(()=>columnLayout.splitColumnsIntoControlledAndUncontrolled(state.collection.columns), [
        state.collection.columns,
        columnLayout
    ]);
    // uncontrolled column widths
    let [uncontrolledWidths, setUncontrolledWidths] = (0, $1BfjW$useState)(()=>columnLayout.getInitialUncontrolledWidths(uncontrolledColumns));
    // combine columns back into one map that maintains same order as the columns
    let colWidths = (0, $1BfjW$useMemo)(()=>columnLayout.recombineColumns(state.collection.columns, uncontrolledWidths, uncontrolledColumns, controlledColumns), [
        state.collection.columns,
        uncontrolledWidths,
        uncontrolledColumns,
        controlledColumns,
        columnLayout
    ]);
    let onColumnResizeStart = (0, $1BfjW$useCallback)((key)=>{
        setResizingColumn(key);
        propsOnColumnResizeStart === null || propsOnColumnResizeStart === void 0 ? void 0 : propsOnColumnResizeStart(key);
    }, [
        propsOnColumnResizeStart,
        setResizingColumn
    ]);
    let onColumnResize = (0, $1BfjW$useCallback)((key, width)=>{
        let newControlled = new Map(Array.from(controlledColumns).map(([key, entry])=>[
                key,
                entry.props.width
            ]));
        let newSizes = columnLayout.resizeColumnWidth(tableWidth, state.collection, newControlled, uncontrolledWidths, key, width);
        let map = new Map(Array.from(uncontrolledColumns).map(([key])=>[
                key,
                newSizes.get(key)
            ]));
        map.set(key, width);
        setUncontrolledWidths(map);
        return newSizes;
    }, [
        controlledColumns,
        uncontrolledColumns,
        setUncontrolledWidths,
        tableWidth,
        columnLayout,
        state.collection,
        uncontrolledWidths
    ]);
    let onColumnResizeEnd = (0, $1BfjW$useCallback)((key)=>{
        setResizingColumn(null);
        propsOnColumnResizeEnd === null || propsOnColumnResizeEnd === void 0 ? void 0 : propsOnColumnResizeEnd(key);
    }, [
        propsOnColumnResizeEnd,
        setResizingColumn
    ]);
    let columnWidths = (0, $1BfjW$useMemo)(()=>columnLayout.buildColumnWidths(tableWidth, state.collection, colWidths), [
        tableWidth,
        state.collection,
        colWidths,
        columnLayout
    ]);
    return (0, $1BfjW$useMemo)(()=>({
            resizingColumn: resizingColumn,
            onColumnResize: onColumnResize,
            onColumnResizeStart: onColumnResizeStart,
            onColumnResizeEnd: onColumnResizeEnd,
            getColumnWidth: (key)=>columnLayout.getColumnWidth(key),
            getColumnMinWidth: (key)=>columnLayout.getColumnMinWidth(key),
            getColumnMaxWidth: (key)=>columnLayout.getColumnMaxWidth(key),
            widths: columnWidths
        }), [
        columnLayout,
        resizingColumn,
        onColumnResize,
        onColumnResizeStart,
        onColumnResizeEnd,
        columnWidths
    ]);
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 

const $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY = "row-header-column-" + Math.random().toString(36).slice(2);
function $788781baa30117fa$var$buildHeaderRows(keyMap, columnNodes) {
    let columns = [];
    let seen = new Map();
    for (let column of columnNodes){
        let parentKey = column.parentKey;
        let col = [
            column
        ];
        while(parentKey){
            let parent = keyMap.get(parentKey);
            // If we've already seen this parent, than it is shared
            // with a previous column. If the current column is taller
            // than the previous column, than we need to shift the parent
            // in the previous column so it's level with the current column.
            if (seen.has(parent)) {
                parent.colspan++;
                let { column: column1 , index: index  } = seen.get(parent);
                if (index > col.length) break;
                for(let i = index; i < col.length; i++)column1.splice(i, 0, null);
                // Adjust shifted indices
                for(let i1 = col.length; i1 < column1.length; i1++)// eslint-disable-next-line max-depth
                if (column1[i1] && seen.has(column1[i1])) seen.get(column1[i1]).index = i1;
            } else {
                parent.colspan = 1;
                col.push(parent);
                seen.set(parent, {
                    column: col,
                    index: col.length - 1
                });
            }
            parentKey = parent.parentKey;
        }
        columns.push(col);
        column.index = columns.length - 1;
    }
    let maxLength = Math.max(...columns.map((c)=>c.length));
    let headerRows = Array(maxLength).fill(0).map(()=>[]);
    // Convert columns into rows.
    let colIndex = 0;
    for (let column2 of columns){
        let i2 = maxLength - 1;
        for (let item of column2){
            if (item) {
                // Fill the space up until the current column with a placeholder
                let row = headerRows[i2];
                let rowLength = row.reduce((p, c)=>p + c.colspan, 0);
                if (rowLength < colIndex) {
                    let placeholder = {
                        type: "placeholder",
                        key: "placeholder-" + item.key,
                        colspan: colIndex - rowLength,
                        index: rowLength,
                        value: null,
                        rendered: null,
                        level: i2,
                        hasChildNodes: false,
                        childNodes: [],
                        textValue: null
                    };
                    // eslint-disable-next-line max-depth
                    if (row.length > 0) {
                        row[row.length - 1].nextKey = placeholder.key;
                        placeholder.prevKey = row[row.length - 1].key;
                    }
                    row.push(placeholder);
                }
                if (row.length > 0) {
                    row[row.length - 1].nextKey = item.key;
                    item.prevKey = row[row.length - 1].key;
                }
                item.level = i2;
                item.colIndex = colIndex;
                row.push(item);
            }
            i2--;
        }
        colIndex++;
    }
    // Add placeholders at the end of each row that is shorter than the maximum
    let i3 = 0;
    for (let row1 of headerRows){
        let rowLength1 = row1.reduce((p, c)=>p + c.colspan, 0);
        if (rowLength1 < columnNodes.length) {
            let placeholder1 = {
                type: "placeholder",
                key: "placeholder-" + row1[row1.length - 1].key,
                colspan: columnNodes.length - rowLength1,
                index: rowLength1,
                value: null,
                rendered: null,
                level: i3,
                hasChildNodes: false,
                childNodes: [],
                textValue: null,
                prevKey: row1[row1.length - 1].key
            };
            row1.push(placeholder1);
        }
        i3++;
    }
    return headerRows.map((childNodes, index)=>{
        let row = {
            type: "headerrow",
            key: "headerrow-" + index,
            index: index,
            value: null,
            rendered: null,
            level: 0,
            hasChildNodes: true,
            childNodes: childNodes,
            textValue: null
        };
        return row;
    });
}
let $788781baa30117fa$var$_Symbol_iterator = Symbol.iterator;
class $788781baa30117fa$export$596e1b2e2cf93690 extends (0, $1BfjW$GridCollection) {
    *[$788781baa30117fa$var$_Symbol_iterator]() {
        yield* this.body.childNodes;
    }
    get size() {
        return this._size;
    }
    getKeys() {
        return this.keyMap.keys();
    }
    getKeyBefore(key) {
        let node = this.keyMap.get(key);
        return node ? node.prevKey : null;
    }
    getKeyAfter(key) {
        let node = this.keyMap.get(key);
        return node ? node.nextKey : null;
    }
    getFirstKey() {
        var _;
        return (_ = [
            ...this.body.childNodes
        ][0]) === null || _ === void 0 ? void 0 : _.key;
    }
    getLastKey() {
        var _rows_;
        let rows = [
            ...this.body.childNodes
        ];
        return (_rows_ = rows[rows.length - 1]) === null || _rows_ === void 0 ? void 0 : _rows_.key;
    }
    getItem(key) {
        return this.keyMap.get(key);
    }
    at(idx) {
        const keys = [
            ...this.getKeys()
        ];
        return this.getItem(keys[idx]);
    }
    constructor(nodes, prev, opts){
        let rowHeaderColumnKeys = new Set();
        let body;
        let columns = [];
        // Add cell for selection checkboxes if needed.
        if (opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) {
            let rowHeaderColumn = {
                type: "column",
                key: $788781baa30117fa$var$ROW_HEADER_COLUMN_KEY,
                value: null,
                textValue: "",
                level: 0,
                index: 0,
                hasChildNodes: false,
                rendered: null,
                childNodes: [],
                props: {
                    isSelectionCell: true
                }
            };
            columns.unshift(rowHeaderColumn);
        }
        let rows = [];
        let columnKeyMap = new Map();
        let visit = (node)=>{
            switch(node.type){
                case "body":
                    body = node;
                    break;
                case "column":
                    columnKeyMap.set(node.key, node);
                    if (!node.hasChildNodes) {
                        columns.push(node);
                        if (node.props.isRowHeader) rowHeaderColumnKeys.add(node.key);
                    }
                    break;
                case "item":
                    rows.push(node);
                    return; // do not go into childNodes
            }
            for (let child of node.childNodes)visit(child);
        };
        for (let node of nodes)visit(node);
        let headerRows = $788781baa30117fa$var$buildHeaderRows(columnKeyMap, columns);
        headerRows.forEach((row, i)=>rows.splice(i, 0, row));
        super({
            columnCount: columns.length,
            items: rows,
            visitNode: (node)=>{
                node.column = columns[node.index];
                return node;
            }
        });
        (0, $1BfjW$swchelperssrc_define_propertymjs)(this, "_size", 0);
        this.columns = columns;
        this.rowHeaderColumnKeys = rowHeaderColumnKeys;
        this.body = body;
        this.headerRows = headerRows;
        this._size = [
            ...body.childNodes
        ].length;
        // Default row header column to the first one.
        if (this.rowHeaderColumnKeys.size === 0) this.rowHeaderColumnKeys.add(this.columns[(opts === null || opts === void 0 ? void 0 : opts.showSelectionCheckboxes) ? 1 : 0].key);
    }
}



const $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION = {
    ascending: "descending",
    descending: "ascending"
};
function $4a0dd036d492cee4$export$907bcc6c48325fd6(props) {
    let [isKeyboardNavigationDisabled, setKeyboardNavigationDisabled] = (0, $1BfjW$useState)(false);
    let { selectionMode: selectionMode = "none"  } = props;
    let context = (0, $1BfjW$useMemo)(()=>({
            showSelectionCheckboxes: props.showSelectionCheckboxes && selectionMode !== "none",
            selectionMode: selectionMode,
            columns: []
        }), [
        props.children,
        props.showSelectionCheckboxes,
        selectionMode
    ]);
    let collection = (0, $1BfjW$useCollection)(props, (nodes, prev)=>new (0, $788781baa30117fa$export$596e1b2e2cf93690)(nodes, prev, context), context);
    let { disabledKeys: disabledKeys , selectionManager: selectionManager  } = (0, $1BfjW$useGridState)({
        ...props,
        collection: collection,
        disabledBehavior: "selection"
    });
    return {
        collection: collection,
        disabledKeys: disabledKeys,
        selectionManager: selectionManager,
        showSelectionCheckboxes: props.showSelectionCheckboxes || false,
        sortDescriptor: props.sortDescriptor,
        isKeyboardNavigationDisabled: collection.size === 0 || isKeyboardNavigationDisabled,
        setKeyboardNavigationDisabled: setKeyboardNavigationDisabled,
        sort (columnKey, direction) {
            var _props_sortDescriptor;
            props.onSortChange({
                column: columnKey,
                direction: direction !== null && direction !== void 0 ? direction : ((_props_sortDescriptor = props.sortDescriptor) === null || _props_sortDescriptor === void 0 ? void 0 : _props_sortDescriptor.column) === columnKey ? $4a0dd036d492cee4$var$OPPOSITE_SORT_DIRECTION[props.sortDescriptor.direction] : "ascending"
            });
        }
    };
}


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $312ae3b56a94a86e$var$TableHeader(props) {
    return null;
}
$312ae3b56a94a86e$var$TableHeader.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , columns: columns  } = props;
    if (typeof children === "function") {
        if (!columns) throw new Error("props.children was a function but props.columns is missing");
        for (let column of columns)yield {
            type: "column",
            value: column,
            renderer: children
        };
    } else {
        let columns1 = [];
        (0, $1BfjW$react).Children.forEach(children, (column)=>{
            columns1.push({
                type: "column",
                element: column
            });
        });
        yield* columns1;
    }
};
/**
 * A TableHeader is a container for the Column elements in a Table. Columns can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `columns` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $312ae3b56a94a86e$export$f850895b287ef28e = $312ae3b56a94a86e$var$TableHeader;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $4ae5314bf50db1a3$var$TableBody(props) {
    return null;
}
$4ae5314bf50db1a3$var$TableBody.getCollectionNode = function* getCollectionNode(props) {
    let { children: children , items: items  } = props;
    yield {
        type: "body",
        hasChildNodes: true,
        props: props,
        *childNodes () {
            if (typeof children === "function") {
                if (!items) throw new Error("props.children was a function but props.items is missing");
                for (let item of items)yield {
                    type: "item",
                    value: item,
                    renderer: children
                };
            } else {
                let items1 = [];
                (0, $1BfjW$react).Children.forEach(children, (item)=>{
                    items1.push({
                        type: "item",
                        element: item
                    });
                });
                yield* items1;
            }
        }
    };
};
/**
 * A TableBody is a container for the Row elements of a Table. Rows can be statically defined
 * as children, or generated dynamically using a function based on the data passed to the `items` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $4ae5314bf50db1a3$export$76ccd210b9029917 = $4ae5314bf50db1a3$var$TableBody;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $1cd244557c2f97d5$var$Column(props) {
    return null;
}
$1cd244557c2f97d5$var$Column.getCollectionNode = function* getCollectionNode(props, context) {
    let { title: title , children: children , childColumns: childColumns  } = props;
    let rendered = title || children;
    let textValue = props.textValue || (typeof rendered === "string" ? rendered : "") || props["aria-label"];
    let fullNodes = yield {
        type: "column",
        hasChildNodes: !!childColumns || title && (0, $1BfjW$react).Children.count(children) > 0,
        rendered: rendered,
        textValue: textValue,
        props: props,
        *childNodes () {
            if (childColumns) for (let child of childColumns)yield {
                type: "column",
                value: child
            };
            else if (title) {
                let childColumns1 = [];
                (0, $1BfjW$react).Children.forEach(children, (child)=>{
                    childColumns1.push({
                        type: "column",
                        element: child
                    });
                });
                yield* childColumns1;
            }
        },
        shouldInvalidate (newContext) {
            // This is a bit of a hack, but it works.
            // If this method is called, then there's a cached version of this node available.
            // But, we need to keep the list of columns in the new context up to date.
            updateContext(newContext);
            return false;
        }
    };
    let updateContext = (context)=>{
        // register leaf columns on the context so that <Row> can access them
        for (let node of fullNodes)if (!node.hasChildNodes) context.columns.push(node);
    };
    updateContext(context);
};
/**
 * A Column represents a field of each item within a Table. Columns may also contain nested
 * Column elements to represent column groups. Nested columns can be statically defined as
 * children, or dynamically generated using a function based on the `childColumns` prop.
 */ // We don't want getCollectionNode to show up in the type definition
let $1cd244557c2f97d5$export$816b5d811295e6bc = $1cd244557c2f97d5$var$Column;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ 
function $70d70eb16ea48428$var$Row(props) {
    return null;
}
$70d70eb16ea48428$var$Row.getCollectionNode = function* getCollectionNode(props, context) {
    let { children: children , textValue: textValue  } = props;
    yield {
        type: "item",
        props: props,
        textValue: textValue,
        "aria-label": props["aria-label"],
        hasChildNodes: true,
        *childNodes () {
            // Process cells first
            if (context.showSelectionCheckboxes && context.selectionMode !== "none") yield {
                type: "cell",
                key: "header",
                props: {
                    isSelectionCell: true
                }
            };
            if (typeof children === "function") for (let column of context.columns)yield {
                type: "cell",
                element: children(column.key),
                key: column.key // this is combined with the row key by CollectionBuilder
            };
            else {
                let cells = [];
                (0, $1BfjW$react).Children.forEach(children, (cell)=>{
                    cells.push({
                        type: "cell",
                        element: cell
                    });
                });
                if (cells.length !== context.columns.length) throw new Error(`Cell count must match column count. Found ${cells.length} cells and ${context.columns.length} columns.`);
                yield* cells;
            }
        },
        shouldInvalidate (newContext) {
            // Invalidate all rows if the columns changed.
            return newContext.columns.length !== context.columns.length || newContext.columns.some((c, i)=>c.key !== context.columns[i].key) || newContext.showSelectionCheckboxes !== context.showSelectionCheckboxes || newContext.selectionMode !== context.selectionMode;
        }
    };
};
/**
 * A Row represents a single item in a Table and contains Cell elements for each column.
 * Cells can be statically defined as children, or generated dynamically using a function
 * based on the columns defined in the TableHeader.
 */ // We don't want getCollectionNode to show up in the type definition
let $70d70eb16ea48428$export$b59bdbef9ce70de2 = $70d70eb16ea48428$var$Row;


/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */ function $941d1d9a6a28982a$var$Cell(props) {
    return null;
}
$941d1d9a6a28982a$var$Cell.getCollectionNode = function* getCollectionNode(props) {
    let { children: children  } = props;
    let textValue = props.textValue || (typeof children === "string" ? children : "") || props["aria-label"] || "";
    yield {
        type: "cell",
        props: props,
        rendered: children,
        textValue: textValue,
        "aria-label": props["aria-label"],
        hasChildNodes: false
    };
};
/**
 * A Cell represents the value of a single Column within a Table Row.
 */ // We don't want getCollectionNode to show up in the type definition
let $941d1d9a6a28982a$export$f6f0c3fe4ec306ea = $941d1d9a6a28982a$var$Cell;







export {$292bc4e09cd0eb62$export$cb895dcf85db1319 as useTableColumnResizeState, $4a0dd036d492cee4$export$907bcc6c48325fd6 as useTableState, $312ae3b56a94a86e$export$f850895b287ef28e as TableHeader, $4ae5314bf50db1a3$export$76ccd210b9029917 as TableBody, $1cd244557c2f97d5$export$816b5d811295e6bc as Column, $70d70eb16ea48428$export$b59bdbef9ce70de2 as Row, $941d1d9a6a28982a$export$f6f0c3fe4ec306ea as Cell, $6555104ff085bef4$re_export$Section as Section, $788781baa30117fa$export$596e1b2e2cf93690 as TableCollection, $a9e7ae544a4e41dd$export$7ff77a162970b30e as TableColumnLayout};
//# sourceMappingURL=module.js.map
